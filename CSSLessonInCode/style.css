/*
 * BASIC CONCEPTS
 * 
 * Order of priority while applying styles - 
 * -----------------------------------------
 * Inline Styles            HIGHEST
 * #ID Selectors                |
 * .class + [attrs] + :psu      |
 * <tag> and :psu               |
 * * (apply to all) selector    |
 * Inhertiance                  V
 *                           LOWEST
 * At same level position of style in .css file determines which style takes precedence.
 * One that appears later in the file overrides ones conflicting and above it.
 * 
 * Combinators -
 * -------------
 * Combinator specifies specificity of applying style. It is used to dictate which specific
 * instance of selector should have the style applied. 
 * For instance if user wants to apply a particular font to a specific h1 selector that is 
 * inside a div with id container, then style declaration can be -
 * 
 * #container h1 { font-family: aerial; }  
 *
 * signifying h1 contained at any level within an element with id container should have this 
 * font family applied. There are many combinators that are available that are listed below.
 *
 * + Adjacent Sibling: postfix selector should directly follow prefix selector and both 
 * should be on the same level.
 * e.g. h2 + p { color: red; }   
 * <h2>welcome</h2>
 * <p>This is welcome subtitle</p>  
 *
 * ~ General Sibling: postfix selector can appear anywhere after prefix selector, doesn't 
 * have to be adjacent, but should be on the same level. 
 * e.g. h2 ~ p { color: red; }
 * <h2>welcome</h2>
 * <h3>to the jungle</h3>
 * <p>This is welcome subtitle</p>
 *
 * > Child: postfix selector gets applied only to direct childs of prefix selector. Nested
 * children other than direct disccendent do not get the styles. 
 * e.g. div > p { color: red; }
 * <div>
 *  <p>This will appear in red</p>
 *  <div><p>This won't</p></div>
 *  <p>And this will</p>
 * </div>
 *  
 * <space> Descendant: every postfix that appears in html inside this prefix gets the style
 * applied, irrelevant if its depth as a child (or child of child.. .)
 * e.g. div p { color: red; }
 * <div><p>This will appear red</p></div>
 * <p>This won't</p>
 *
 * <no-space> Same Element: used to indicate elements having all selectors joined back to back. 
 * In example below this style is applied to h2 element with id my-id and class my-style
 * e.g. h2#my-id.my-style { color: red; }
 *
 * While applying combinators keep performance in mind. The more specific combinator application
 * is the better it will perform. The more generic and widespread it is, it will perform badly. 
 * #id > #id -- will perform awesome | while | body * -- this is immensely poor.
 *
 * Box Model -
 * -----------
 * + Margin : space outside of element, does not overlap with padding of child elements
 * | but adjacent elements can have overlapping margins and bigger margin wins
 * |--- Border : border of the element. Can be manipulated to behave like margin/padding
 * |------ Padding : space inside of element, between border and content.
 * |--------- Content : actual content.
 *
 */

#lesson-dummy-id {
    /*
     * width: default width of html/body is whole viewport. So when width is defined as 100%
     * element takes entire width of its parent component (only).
     *
     * height: default height of html/body is as much content it holds. So 100% on an element
     * will only take up 100% of "available" space in parent (including own margin). 
     */
    width: calc(100% - 50px);
    height: 100%;

    /*
     * when we declare width & height of an element it sets it for the content (without border
     * padding and margin). These things add up to the content resulting in overall size 
     * larger than what was specified. This is due to behavior of box-sizing. Default value is
     * content-box: size applies to content
     * border-box: size applies to content + border + padding (used almost always) 
     */
    box-sizing: border-box;

    /*
     * display property indicates how the element will be rendered on page. 
     *
     * inline: inline elements are placed adjacent to each other. e.g. of default inline element
     * is a tag. these elements take width equal to content and do not allow setting height of the
     * element. Margin and padding on horitzontal scale do not overlap but vertical ones do. The
     * element stays in place vertically while adding maring and padding to overlap with block 
     * elements.
     *
     * block: block elements take entire space they're placed pushing other elements to render
     * away from them. 
     * 
     * inline-block: they take width equal to content and sit next to each other but allow placing
     * top/bottom margin/padding that behaves like block and moves the carrying element not allowing
     * overlap with other block elements. User can set height attribute to a inline-block element. 
     *
     * none: element is still available in dom but just not visible. Handy to play around with js.
     * 
     * float: float removes an element from normal document flow and floats it over other elements
     * in its position. This may result in other elements displaying underneath the floating 
     * element. To curb this, we need hacks like using a placeholder div and using clear: both or
     * left/right to clear elements from under the floating element. There are lot of issues with
     * float and with advent of flexbox and grid should be avoided at all costs.
     */
    display: inline-block;

    /*
     * Position styling can be applied to block level as well as inline elements alike. 
     *
     * positioning context: values for some position attributes have to be defined as <amount> 
     * w.r.t. <some context> from [top, right, bottom, left]. This <some context> is positioning
     * context. 
     * 
     * static: (default) static has document's default flow and things are placed in sequence one
     * after another. Block elements will take their space and inline would be placed adjacent to
     * each other. Elements will not overlap. Basically, this his how deafult html flow behaves.
     * Position values (TRBL) do not work with static. They are meant for position other than the
     * deafult one. 
     * position context: viewport
     *
     * absolute: positioning of element is fixed w.r.t. its parent and moves along with parent
     * element on scroll. TRBL values can be applied to move the element around w.r.t. ancestor.
     * position context: first ancestor with position property. (html if none).
     *
     * relative: positioning of element is relative to itself. This position value is handy even
     * when a child element needs absolute positioning and needs parent to have position property
     * on it. This can be used to move elements to TRBL combinations.
     * If TRBL value moves element out of parent, overflow: hidden property can be used to prevent
     * it from wandering. Overflow on body does not work as it delegates it to html. 
     * parent is any element with block level (for static too)
     * 
     * fixed: takes the element out of document flow and element appears with attributes of inline
     * block display type. It fixes the element in a position that does not move with scroll. 
     * This is because the position is fixed w.r.t. viewport and stays the same irrespective of 
     * page scroll.
     * 
     * sticky: this is a fun position property. Sticky position is used with TRBL in order to 
     * come into effect. It is scrollable till specified TRBL value reaches and then sticks to 
     * the parent frame. Its existence is till its parent container and will scroll away if parent
     * component scrolls out of the frame. 
     * [best used] with navbars that scroll and stick to top. 
     * 
     * z-index: places an element in document along z-axis. Default value is 0 on flat plant. Any
     * value -ve puts it background and +ve brings it forward. z-index works only with position 
     * property (even if it is static). Without it it has no effect.
     */
    position: static; /* default */

    /* 
     * Set element's vertical alignment to middle 
     * !important: overrides style at all other levels. Bad practice to use it & avoid at all costs
     */
    vertical-align: middle !important;

    /*
     * background-image: sets background image for the element. 
     * linear-gradient(<from>, <to>, <fromcolor> [upto x%], <tocolor>);
     * radial-gradient(<from> [inside], <to> [outside], <fromcolor>, <tocolor>);
     * 
     * stacked background can be created by stacking multiple images/backgrounds on top of each 
     * other. This is done by specifying backgrounds with all each's shorthand properties together
     * separated by commas. 
     * background: linear-gradient(red, blue), url("img") 50%/100% auto border-box, #dede23;
     * order: HIGH <------------------------------------------------------------------- LOW
     * 
     * background-color: sets background color for the element. If background-image is also defined
     * for the element, both apply. Image sits on top of color. 
     * 
     * background-size: <width> <height>; defines image dimensions. There are predefined values 
     * by names like cover (landscape: width: 100% height: auto | portrait: width: auto, height:
     * 100%) that can maintain aspect ratio. 
     * Sizing image by putting size restrictions on parent does not impact image as images do not
     * respect containing element's dimensions (iff they are inline). If they're made block or 
     * inline-block, parents dimensions would restrict image size. 
     *
     * background-position: x-edge, y-edge; moves the image by mentioned values. % dictate how the
     * regions not displayed in element are distributed, e.g. 50% can distribute on top & bottom.
     * Defines values from left and top.
     *
     * background-origin: border-box | content-box | padding-box. Same as box-sizing. As image is 
     * cropped and oversized, when border is applied image under the cropped region comes into 
     * play and takes up border region (under the border) and can result in distorted layout. To
     * handle this use border-box to set border within visible image area.
     *
     * background-clip: border-box -> image under border | padding-box -> no image under border | 
     * content-box -> clip before padding.
     * 
     * background-attachment: makes image scrollable. Not really used that much. Fixed value 
     * keeps the image fixed to the viewport.
     *
     * shorthand-
     * background: <url> [position]/[size] [repeat] [origin] [clip]
     *
     * NOTE :
     * border-box: content + padding + border
     * padding-box: content + padding
     * content-box: just content
     */
     background-image: url("img.png");
     background-origin: border-box;

     /*
      * [x]em: x times font size of parent element. Ultimate parent element is document on which 
      * browser's font size is applied (root em or rem). So in short all em sizes are relative to 
      * their parent which is relative to at top level to browser font, unless the hierarchy 
      * encounters a static font size value in chain. 
      * Use em only for leaf nodes to avoid mess.
      *
      * rem: is better in terms of stability than em as all fonts defined as rem unit are w.r.t.
      * browser font. Parent fonts are relative, for e.g. root of 10px and div of 1.2em = 12px 
      * will have its child's font (as declared) 1.5em = 12 * 1.5 = 18em. This can cause a lot of
      * confusion and mess to handle. rem can serve in such cases.
      * rem can be applied to other properties than font (like margin, width, etc).
      */
     font-size: 1.5em;
}

/* 
 * pseudo classes allow adding style to specific state of an element. 
 * :hover :active :any :first-child :nth-child() :read-only :required :right :disabled etc.
 * e.g. a:not(.active) - anchor tag that does not have active class.
 *
 * pseudo element allows adding style to specific part of an element. 
 * ::before ::after ::first-letter ::first-line ::grammar-error ::spelling-error
 *
 */
#some-dummy-id a:hover { font: inherit; }

/*
 * Advanced attributes: attributes can be specifically chosen based on complete or partial 
 * values they hold. 
 *
 * element[attribute] - this selector picks element that has mentioned attribute
 * element[attribute="value"] - same as above but further restircts on value with attribute
 * 
 * ~= contains specified value among list of different values on element.
 * |= value starts with provided value followed by - and something
 * ^= prefix with mentioned value
 * $= suffix with mentioned value
 * *= contains anywhere in the value.
 * [sr*="cdn" i] - i here stands for case insensitive match.
 */
[lang~="en-us"] { font: inherit; }


/*
 * FLEXBOX
 * -------
 * display:flex - makes the element container of flex box. This container will contain elements
 * which can be manipulated using flex properties. Container size is adjusted according to
 * max/min space required by flex items based on how their widths and heights are defined.
 * Properties that are not defined are available for adjustment to fit into container well. This
 * is managed by the container. 
 *
 * display: inline-flex - takes up required space on main axis and does not change size based on
 * resolution (more kind of fixed in size) -> anti-block level behavior.
 *
 * flex-wrap: nowrap | wrap - indicates wrap behavior when element size exceeds container size.
 * With no wrap container adjusts to required size while in case of wrap overflowing items move
 * to next col/rol.
 * [wrap-reverse]: aligns and wraps in reverse order. In case of x-axis primary alignment works
 * bottom to top and wrap moves wrapped items to top instead of below.
 * 
 * Parent (container) can have following props
 * 
 * flex-direction: defines main axis of flex container along with flex elements are arranged.
 * [row | col] - default is row. For col items are aligned one below other along y-axis (mobile)
 * ----> row (from top if col) | <---- row-reverse (from bottom if col-reverse) |
 * V col (if row, then from top left corner) | ^ col-reverse (if row-reverse from top right corner)
 * 
 * flex-flow: shorthand for flex-direction and flex-wrap
 *
 * justify-content: sets alignment along main axis. Row - horz. alignment, col - vert. alignment
 *
 * align-content: aligns items along cross axis. Manages separation between different lines of
 * cross axis. (Need further study)
 *
 * align-items: sets alignment along cross axis. Row - sets vertical alignment, col - sets horz.
 *
 * Child components (flex items) can have following properties
 *
 * flex-grow: 2 - flex grow property defines in what proportion elements will grow in size when 
 * display size changes. An item with flex-grow: 1 and another with flex-grow: 2 will lead to 
 * elements growing in proportion 1:3 and 2:3. 
 * similar to flex-grow is flex-shrink. flex-grow/shrink: 0 sets the items to fixed size and 
 * does not allow to grow or shrink in size when dimensions change. 
 *
 * align-self: aligns a single flex item along cross axis. It can take same values as align-items
 * however the main difference is the elements this style gets applied to.
 *
 * order: arranges flex items within a flex container sorted by this order. Default order for items
 * is 0. Any one item with -ve value will become first and +ve value will become last.
 *
 * flex-basis: 200px; flex-basis defines the size along main axis. So a value of 200px will 
 * override width if flex-direction is row and override height if its column. However flex-basis
 * auto sets the actual width/height defined in for the class and does not override. 
 */​
 #flex-demo { display: flex; }

 /*
  * GRID
  * ----
  * 
  * display: grid; is defined in an element to make it a grid container. Container forms the canvas
  * that is divided into grid of rows and columns of variable spans. 
  *
  * grid-template-columns: 200px 2fr 20% 3fr | repeat(4, 10% 15%); repeats | minmax(10%, 50%)
  * This property is defined in grid container. By default a grid is single row single column 
  * component. This has to be explicitly broken down using grid-template-xxx property. In case above
  * grid is broken into 200px, 20%, and 5 fractions of (100% - 200px - 20%) divided in 2 chunks of
  * 2fr and 3fr.
  * repeat repeats the arg2 pattern x times (arg1)
  * repeat(autofill, 10rem) - adds/reduces number of cols as viewport size changes. autofit instead 
  * of autofill also aligns grid in center when there is additional space available. 
  * minmax allows conatiner to manage element size between min and max values.
  *
  * grid-template-areas: name name .. 
  *                      name name ..
  * creates a named matrix type grid by names. use grid-area: name in grid element to identify 
  * which named area it is going to occupy in the grid.
  *
  * justify-items / align-items: (deafult) stretch | center | start | end;
  * same as defined in flex box. Really cool when applied to grid. 
  * 
  * justify-content / align-content: aligns entire grid along main/cross axis. This is used when you 
  * want to align the grid, say center of the container area (when grid has unused area).
  *
  * grid-auto-rows: size; sets size of automatically genarated rows for dynamic content (Rows).
  * 
  * grid-auto-flow: (default) row | column [dense]; appends new rows | cols for dynamically added 
  * content. Dense ensures dom rule of not putting content in area that is empty due to viewport
  * size (and not mentioning start/end for items) is NOT respected and items occupy empty space. 
  *
  * Child Components:
  *
  * grid-column-start: 3; grid-column-end: 5; These properties indicate grid line (col. start edge)
  * from which the current grid element should start and grid line at which it should end. This is 
  * required to span a cell across multiple columns. 
  *
  * grid-row-start: 1; grid-row-end: 3; Similar to grid-column-xx component, applied across rows.
  * values can also be -ve indicating lines from end or as 'span x' indicating start with line 1 and
  * span x cols. Nothing happens if span makes element to overflow available area.
  * shorthand: grid-column: x (start) / y (end);
  * 
  * grid-area: x-start / sizex / y-start / sizey
  *
  * grid-row-gap:
  * grid-column-gap: 5px; adds gap of 5px to column (vertical).
  * shorthand: grid-gap: row col;
  * 
  * Grid elements can overlap. To manipulate which one appears on top use z-index.
  *
  * justify-self / align-self: position a single grid element along main/cross axis. 
  * 
  */
 #grid-demo { display: grid; }

 /*
  * TRANSFORM & TRANSITION
  * ----------------------
  *
  * >> transform: 
  *
  * rotate<X|Y|Z>(xdeg) - rotates the element by x degrees around origin (default center).
  *
  * translate<X|Y|Z|3D>(xunits) - moves the element along x,y,z axis by mentioned units. If used with 
  * rotate, keep in mind the movement will be along a rotated axis. 
  *
  * skew<X|Y>(xdeg) - skew the element by mentioned degrees along given axis. skew(x y) shorthand.
  *
  * scale<X|Y>(x) - scales element along given axis x times. scale(x) shorthand for x on both axis. 
  *
  * perspective(xunit) - sets perspsective (distance from object) for the element. This gives persp 
  * in sketches kind of look to element. 
  * Theres also a perspective: xunit property that should be 
  * applied to parent/container to have same perspective for all the items inside it. 
  * perspective-origin: left | right | xunits .. . moves the position of observert and adjusts appearance
  * of element accordingly. 
  *
  * transform-style: flat(default) | preserve-3d (maintains element positions in 3d space)
  *
  * backface-visibility: when rotating/flipping an element show or hide backface(side).
  *
  * transform-origin: center | start | end | Xpx Ypx
  * defines where the origin of element lies. Futher transformations like rotate are applied across
  * this defined origin.   
  *
  * >> transition:
  *
  * transition: <property> <duration> <style> <delay>
  * e.g. transition: opacity 500ms ease-out 500ms;
  * in above example opacity change on action will transit in .5 sec with a delayed start of .5 sec
  * and will slow down in animation towards the end (ease out).
  * timing - cubic-bezier(duration-part1, dp2, dp3, dp4) @READ
  * 
  * NOTE: applying transitin to displayproperty does not add delay. To do that use setTimeout() in JS.
  */
#trans-demo { transform: rotateX('45deg'); }

 /* 
  * ANIMATIONS
  * ----------
  * 
  * @keyframes - defines frames at different time intervals. CSS does smoothening of transition between
  * defined keyframes. 
  * e.g. wiggle in style below. 
  * to apply this animation to a selector use 
  * animation: wiggle [animie_duration] [delay] [# of iterations] [state after animation]
  * final state: alternate | reverse | forwards (final animation state) | backwards (starting state)
  * 
  * animation: wiggle 500ms 1s ease-out forwards 1;
  */
@keyframes wiggle { 
    0% {
        /* any css proprety can be animated */
        transform: rotateZ(0deg);
    }
    60% {
        transform: rotateZ(90deg);
    }
    80% { 
        transform: rotateZ(65deg);
    }
    100% {
        transform: rotateZ(70deg);
    }
}
 /* 
  * MEDIA QUERIES
  *
  * Syntax: @media (conditions that evaluate to true/false)
  * Within media query is regular css code -> styles that apply to elements once the media 
  * condition is true.
  *
  * Order of media query is important. For same matching conditions the one defined later takes
  * prcedence. For different conditions this is more like exception handling in Java. Ensure 
  * for e.g. min-width with lesser value is defined first. Else the later always one remains true 
  * and the other media queries are overridden.
  * 
  * Some useful logical attributes - 
  * min-width | max-width | min-height | max-height: select resolution of device to switch style
  * orientation: portrait | landscape: to manage view based on mobile orientation
  * 
  */
@media (min-width: 640px) and (min-height: 720px) {
    h1 { color: red; }
}

/* 
 * HACKS
 * 
 * Remove outline from focused elements like button
 * ------------------------------------------------
 * <selector>:focus { outline: none; } 
 *
 * Merge separate outlines on cell creating thick borders
 * ------------------------------------------------------
 * border-collapse: collapse;
 *
 * Element moves out of page width introducing a scrollbar
 * -------------------------------------------------------
 * This is most probably due to margins and borders adding on top of elements width (probably)
 * defined as 100%. To fix this, use box-sizing: border-box which will stick all the attributes 
 * of box (margin, padding, border, box-shadow) within specified limits.
 *
 * Box-shadow in image leaves a white region between image and shadow
 * ------------------------------------------------------------------
 * vertical-align: top; (this will remove the white region in bottom)
 * 
 */

html { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    scroll-behavior: smooth;
}

body {
    margin: 0;
    color: rgb(52, 52, 53);
}

a {
    text-decoration: none;
    color: inherit; 
}

a:hover, a:active {
    color: rgb(167, 167, 167);
}

span.title {
    font-size: 2em;
    font-weight: bold;
}

#goto-top-anchor {
    position: fixed;
    bottom: 1vh;
    right: 1vw;
    border-bottom: 20px solid red;
    border-left: 20px solid rgba(0,0,0,0);
    border-right: 20px solid rgba(0,0,0,0);
}

.navbar {
    display: inline-block;
    width: 100%;
    line-height: 2rem;
    vertical-align: middle;
    box-sizing: border-box;
    position: sticky;
    top: 0;
    padding: 1vh 0;
    background-color: rgba(0,0,0,.7);
    color: #f7f7f7;
    margin: 6vh 0 2vh;
    filter: invert();
}

.logo {
    display: inline;
    font-weight: bold;
    margin-left: 2vw;
    font-size: 2rem;
}

ul {
    display: inline;
    right: 2vw;
    margin: 0;
    position: absolute;
}

li.button {
    display: inline-block;
    padding: 0 1vw;

}

.content-container {
    margin: 0 20%;
    text-align: justify;
}

.content-container > p {
    padding: 1vh 0;
    line-height: 1.5em;
}

.home-img {   
    background: url("images/test-img.jpg");
    background-size: 100% auto;
    background-repeat: no-repeat;
    background-position-y: 50%;
    width: 100%;
    box-sizing: border-box;
    height: 100vh;
    display: block;
    background-clip: border-box;
    top: 0;
    position: absolute;
    z-index: -1;
}

.home-img-clear {
    margin-top: 90vh;
}

.shapes {
    display: flex;
    flex-direction: row;
    align-items: flex-end;
    margin: 2rem 0;
}

.shape {}

.blocks {
    display: grid;
    grid-template-columns: 30% 20% 4fr 2fr;
    margin: 3rem 0;
    border: 1px dashed blue;
}

.block {
    border: 1px dotted red;
}

.b1 { 
    background-color: #5194d8; 
    grid-row-start: 1;
    grid-row-end: 3;
}
.b2 { 
    background-color: #51d8c6; 
    height: 5rem;
}
.b3 { 
    background-color: #d85189; 
    grid-column-start: 3;
    grid-column-end: 5;
}
.b4 { 
    background-color: #d8d651; 
    grid-column-start: 2; grid-column-end: 4;
}
.b5 { 
    background-color: #5351d8; 
    height: auto;
}

.trans {
    width: 200px;
    height: 50px;
    background-color: #d85189;
    margin-bottom: 100px;
    transform-origin: top left;
    animation: wiggle 500ms 1s ease-out forwards 1;
}

@media (max-width: 1423px) {
    .home-img {  
        background-size: auto 100vh;
        background-position-x: 50%;
    }
}

@media (max-width: 768px) {
    ul.buttons {
        display: none;
    }

    .content-container {
        margin: 2rem;
    }
    .home-img {  
        background-size: 100% auto;
        background-position: 0 0;
        position: absolute;
    }
    .home-img-clear {
        margin-top: 50vh;
    }
    .logo {
        font-size: 1.2rem;
    }

    .navbar {
        line-height: 1.2rem;
    }
    
}

/* 
 * PLAYING WITH SHAPES
 * 
 * Square & Rectangle: these are pretty simple that can be manipulated with div width and height
 * 
 * Triangle: for any shape with upto 4 edges, we can manipulate simple div and play around with 
 * border properties. For triangle we can have a div with fat borders making a rectangle. However
 * removing top border makes left and right fall over to each other to form triangle. Same behavior
 * can be used to create other shapes.
 *
 * Circle: square with border radius 50%.
 * 
 * Ellipse: Rectangle with border radius 50%.
 *
 * Trapezoid: Trapezoid is a little tricky. When borders are created with thickness they create a
 * block on top of each edge. That leaves TL TR BL BR edges (small corner squares) empty. So CSS
 * divides this 50-50 (diagonal partition). So if size of original block is 0, we'll end up with 
 * diagonal line partitions. (For a block of small size with thick borders, imagine overall figure
 * as pyramid with chopped top and seen as a top view).
 * 
 */
.triangle {
    display: inline-block;
    width: 0px;
    border-left: 50px solid rgba(0,0,0,0);
    border-right: 50px solid rgba(0,0,0,0);
    border-bottom: 50px solid red;
    order: 5;
}

.square {
    display: inline-block;
    width: 50px;
    height: 50px;
    background: red;
    order: 10;
}

.rectangle {
    display: inline-block;
    width: 75px;
    height: 50px;
    background: red;
}

.circle {
    display: inline-block;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: red;   
}

.ellipse {
    display: inline-block;
    width: 100px;
    height: 50px;
    border-radius: 50%;
    background: red;
}

.trapezoid {
    display: inline-block;
    width: 40px;
    border-left: 30px solid rgba(0,0,0,0);
    border-right: 30px solid rgba(0,0,0,0);
    border-bottom: 50px solid red;
}