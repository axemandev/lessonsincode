/*
 * BASIC CONCEPTS
 * 
 * Order of priority while applying styles - 
 * -----------------------------------------
 * Inline Styles            HIGHEST
 * #ID Selectors                |
 * .class + [attrs] + :psu      |
 * <tag> and :psu               |
 * * (apply to all) selector    |
 * Inhertiance                  V
 *                           LOWEST
 * At same level position of style in .css file determines which style takes precedence.
 * One that appears later in the file overrides ones conflicting and above it.
 * 
 * Combinators -
 * -------------
 * Combinator specifies specificity of applying style. It is used to dictate which specific
 * instance of selector should have the style applied. 
 * For instance if user wants to apply a particular font to a specific h1 selector that is 
 * inside a div with id container, then style declaration can be -
 * 
 * #container h1 { font-family: aerial; }  
 *
 * signifying h1 contained at any level within an element with id container should have this 
 * font family applied. There are many combinators that are available that are listed below.
 *
 * + Adjacent Sibling: postfix selector should directly follow prefix selector and both 
 * should be on the same level.
 * e.g. h2 + p { color: red; }   
 * <h2>welcome</h2>
 * <p>This is welcome subtitle</p>  
 *
 * ~ General Sibling: postfix selector can appear anywhere after prefix selector, doesn't 
 * have to be adjacent, but should be on the same level. 
 * e.g. h2 ~ p { color: red; }
 * <h2>welcome</h2>
 * <h3>to the jungle</h3>
 * <p>This is welcome subtitle</p>
 *
 * > Child: postfix selector gets applied only to direct childs of prefix selector. Nested
 * children other than direct disccendent do not get the styles. 
 * e.g. div > p { color: red; }
 * <div>
 *  <p>This will appear in red</p>
 *  <div><p>This won't</p></div>
 *  <p>And this will</p>
 * </div>
 *  
 * <space> Descendant: every postfix that appears in html inside this prefix gets the style
 * applied, irrelevant if its depth as a child (or child of child.. .)
 * e.g. div p { color: red; }
 * <div><p>This will appear red</p></div>
 * <p>This won't</p>
 *
 * <no-space> Same Element: used to indicate elements having all selectors joined back to back. 
 * In example below this style is applied to h2 element with id my-id and class my-style
 * e.g. h2#my-id.my-style { color: red; }
 *
 * While applying combinators keep performance in mind. The more specific combinator application
 * is the better it will perform. The more generic and widespread it is, it will perform badly. 
 * #id > #id -- will perform awesome | while | body * -- this is immensely poor.
 *
 * Box Model -
 * -----------
 * + Margin : space outside of element, does not overlap with padding of child elements
 * | but adjacent elements can have overlapping margins and bigger margin wins
 * |--- Border : border of the element. Can be manipulated to behave like margin/padding
 * |------ Padding : space inside of element, between border and content.
 * |--------- Content : actual content.
 *
 */

#lesson-dummy-id {
    /*
     * width: default width of html/body is whole viewport. So when width is defined as 100%
     * element takes entire width of its parent component (only).
     *
     * height: default height of html/body is as much content it holds. So 100% on an element
     * will only take up 100% of "available" space in parent (including own margin). 
     */
    width: calc(100% - 50px);
    height: 100%;

    /*
     * when we declare width & height of an element it sets it for the content (without border
     * padding and margin). These things add up to the content resulting in overall size 
     * larger than what was specified. This is due to behavior of box-sizing. Default value is
     * content-box: size applies to content
     * border-box: size applies to content + border + padding (used almost always) 
     */
    box-sizing: border-box;

    /*
     * display property indicates how the element will be rendered on page. 
     *
     * inline: inline elements are placed adjacent to each other. e.g. of default inline element
     * is a tag. these elements take width equal to content and do not allow setting height of the
     * element. Margin and padding on horitzontal scale do not overlap but vertical ones do. The
     * element stays in place vertically while adding maring and padding to overlap with block 
     * elements.
     *
     * block: block elements take entire space they're placed pushing other elements to render
     * away from them. 
     * 
     * inline-block: they take width equal to content and sit next to each other but allow placing
     * top/bottom margin/padding that behaves like block and moves the carrying element not allowing
     * overlap with other block elements. User can set height attribute to a inline-block element. 
     *
     * none: element is still available in dom but just not visible. Handy to play around with js.
     * 
     * float: float removes an element from normal document flow and floats it over other elements
     * in its position. This may result in other elements displaying underneath the floating 
     * element. To curb this, we need hacks like using a placeholder div and using clear: both or
     * left/right to clear elements from under the floating element. There are lot of issues with
     * float and with advent of flexbox and grid should be avoided at all costs.
     */
    display: inline-block;

    /*
     * Position styling can be applied to block level as well as inline elements alike. 
     *
     * positioning context: values for some position attributes have to be defined as <amount> 
     * w.r.t. <some context> from [top, right, bottom, left]. This <some context> is positioning
     * context. 
     * 
     * static: (default) static has document's default flow and things are placed in sequence one
     * after another. Block elements will take their space and inline would be placed adjacent to
     * each other. Elements will not overlap. Basically, this his how deafult html flow behaves.
     * Position values (TRBL) do not work with static. They are meant for position other than the
     * deafult one. 
     * position context: viewport
     *
     * absolute: positioning of element is fixed w.r.t. its parent and moves along with parent
     * element on scroll. TRBL values can be applied to move the element around w.r.t. ancestor.
     * position context: first ancestor with position property. (html if none).
     *
     * relative: positioning of element is relative to itself. This position value is handy even
     * when a child element needs absolute positioning and needs parent to have position property
     * on it. This can be used to move elements to TRBL combinations.
     * If TRBL value moves element out of parent, overflow: hidden property can be used to prevent
     * it from wandering. Overflow on body does not work as it delegates it to html. 
     * parent is any element with block level (for static too)
     * 
     * fixed: takes the element out of document flow and element appears with attributes of inline
     * block display type. It fixes the element in a position that does not move with scroll. 
     * This is because the position is fixed w.r.t. viewport and stays the same irrespective of 
     * page scroll.
     * 
     * sticky: this is a fun position property. Sticky position is used with TRBL in order to 
     * come into effect. It is scrollable till specified TRBL value reaches and then sticks to 
     * the parent frame. Its existence is till its parent container and will scroll away if parent
     * component scrolls out of the frame. 
     * [best used] with navbars that scroll and stick to top. 
     * 
     * z-index: places an element in document along z-axis. Default value is 0 on flat plant. Any
     * value -ve puts it background and +ve brings it forward. z-index works only with position 
     * property (even if it is static). Without it it has no effect.
     */
    position: static; /* default */

    /* 
     * Set element's vertical alignment to middle 
     * !important: overrides style at all other levels. Bad practice to use it & avoid at all costs
     */
    vertical-align: middle !important;

    /*
     * background-image: sets background image for the element. 
     * linear-gradient(<from>, <to>, <fromcolor> [upto x%], <tocolor>);
     * radial-gradient(<from> [inside], <to> [outside], <fromcolor>, <tocolor>);
     * 
     * stacked background can be created by stacking multiple images/backgrounds on top of each 
     * other. This is done by specifying backgrounds with all each's shorthand properties together
     * separated by commas. 
     * background: linear-gradient(red, blue), url("img") 50%/100% auto border-box, #dede23;
     * order: HIGH <------------------------------------------------------------------- LOW
     * 
     * background-color: sets background color for the element. If background-image is also defined
     * for the element, both apply. Image sits on top of color. 
     * 
     * background-size: <width> <height>; defines image dimensions. There are predefined values 
     * by names like cover (landscape: width: 100% height: auto | portrait: width: auto, height:
     * 100%) that can maintain aspect ratio. 
     * Sizing image by putting size restrictions on parent does not impact image as images do not
     * respect containing element's dimensions (iff they are inline). If they're made block or 
     * inline-block, parents dimensions would restrict image size. 
     *
     * background-position: x-edge, y-edge; moves the image by mentioned values. % dictate how the
     * regions not displayed in element are distributed, e.g. 50% can distribute on top & bottom.
     * Defines values from left and top.
     *
     * background-origin: border-box | content-box | padding-box. Same as box-sizing. As image is 
     * cropped and oversized, when border is applied image under the cropped region comes into 
     * play and takes up border region (under the border) and can result in distorted layout. To
     * handle this use border-box to set border within visible image area.
     *
     * background-clip: border-box -> image under border | padding-box -> no image under border | 
     * content-box -> clip before padding.
     * 
     * background-attachment: makes image scrollable. Not really used that much. Fixed value 
     * keeps the image fixed to the viewport.
     *
     * shorthand-
     * background: <url> [position]/[size] [repeat] [origin] [clip]
     *
     * NOTE :
     * border-box: content + padding + border
     * padding-box: content + padding
     * content-box: just content
     */
     background-image: url("img.png");
     background-origin: border-box;

     /*
      * [x]em: x times font size of parent element. Ultimate parent element is document on which 
      * browser's font size is applied (root em or rem). So in short all em sizes are relative to 
      * their parent which is relative to at top level to browser font, unless the hierarchy 
      * encounters a static font size value in chain. 
      * Use em only for leaf nodes to avoid mess.
      *
      * rem: is better in terms of stability than em as all fonts defined as rem unit are w.r.t.
      * browser font. Parent fonts are relative, for e.g. root of 10px and div of 1.2em = 12px 
      * will have its child's font (as declared) 1.5em = 12 * 1.5 = 18em. This can cause a lot of
      * confusion and mess to handle. rem can serve in such cases.
      * rem can be applied to other properties than font (like margin, width, etc).
      */
     font-size: 1.5em;
}

/* 
 * pseudo classes allow adding style to specific state of an element. 
 * :hover :active :any :first-child :nth-child() :read-only :required :right :disabled etc.
 * e.g. a:not(.active) - anchor tag that does not have active class.
 *
 * pseudo element allows adding style to specific part of an element. 
 * ::before ::after ::first-letter ::first-line ::grammar-error ::spelling-error
 *
 */
#some-dummy-id a:hover { font: inherit; }

/*
 * Advanced attributes: attributes can be specifically chosen based on complete or partial 
 * values they hold. 
 *
 * element[attribute] - this selector picks element that has mentioned attribute
 * element[attribute="value"] - same as above but further restircts on value with attribute
 * 
 * ~= contains specified value among list of different values on element.
 * |= value starts with provided value followed by - and something
 * ^= prefix with mentioned value
 * $= suffix with mentioned value
 * *= contains anywhere in the value.
 * [sr*="cdn" i] - i here stands for case insensitive match.
 */
[lang~="en-us"] { font: inherit; }

 /* 
  * MEDIA QUERIES
  *
  * Syntax: @media (conditions that evaluate to true/false)
  * Within media query is regular css code -> styles that apply to elements once the media 
  * condition is true.
  *
  * Order of media query is important. For same matching conditions the one defined later takes
  * prcedence. For different conditions this is more like exception handling in Java. Ensure 
  * for e.g. min-width with lesser value is defined first. Else the later always one remains true 
  * and the other media queries are overridden.
  * 
  * Some useful logical attributes - 
  * min-width | max-width | min-height | max-height: select resolution of device to switch style
  * orientation: portrait | landscape: to manage view based on mobile orientation
  * 
  */
@media (min-width: 640px) and (min-height: 720px) {
    h1 { color: red; }
}

/* 
 * HACKS
 * 
 * Remove outline from focused elements like button
 * ------------------------------------------------
 * <selector>:focus { outline: none; } 
 *
 * Merge separate outlines on cell creating thick borders
 * ------------------------------------------------------
 * border-collapse: collapse;
 *
 * Element moves out of page width introducing a scrollbar
 * -------------------------------------------------------
 * This is most probably due to margins and borders adding on top of elements width (probably)
 * defined as 100%. To fix this, use box-sizing: border-box which will stick all the attributes 
 * of box (margin, padding, border, box-shadow) within specified limits.
 *
 * Box-shadow in image leaves a white region between image and shadow
 * ------------------------------------------------------------------
 * vertical-align: top; (this will remove the white region in bottom)
 * 
 */

html { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    scroll-behavior: smooth;
}

body {
    margin: 0;
    color: rgb(52, 52, 53);
}

a {
    text-decoration: none;
    color: inherit; 
}

a:hover, a:active {
    color: rgb(167, 167, 167);
}

span.title {
    font-size: 2em;
    font-weight: bold;
}

#goto-top-anchor {
    position: fixed;
    bottom: 1vh;
    right: 1vw;
    border-bottom: 20px solid red;
    border-left: 20px solid rgba(0,0,0,0);
    border-right: 20px solid rgba(0,0,0,0);
}

.navbar {
    display: inline-block;
    width: 100%;
    line-height: 2rem;
    vertical-align: middle;
    box-sizing: border-box;
    position: sticky;
    top: 0;
    padding: 1vh 0;
    background-color: rgba(0,0,0,.7);
    color: #f7f7f7;
    margin: 6vh 0 2vh;
    filter: invert();
}

.logo {
    display: inline;
    font-weight: bold;
    margin-left: 2vw;
    font-size: 2rem;
}

ul {
    display: inline;
    right: 2vw;
    margin: 0;
    position: absolute;
}

li.button {
    display: inline-block;
    padding: 0 1vw;

}

.content-container {
    margin: 0 20%;
    text-align: justify;
}

.content-container > p {
    padding: 1vh 0;
    line-height: 1.5em;
}

.home-img {   
    background: url("images/test-img.jpg");
    background-size: 100% auto;
    background-repeat: no-repeat;
    background-position-y: 50%;
    width: 100%;
    box-sizing: border-box;
    height: 100vh;
    display: block;
    background-clip: border-box;
    top: 0;
    position: absolute;
    z-index: -1;
}

.home-img-clear {
    margin-top: 90vh;
}

@media (max-width: 1423px) {
    .home-img {  
        background-size: auto 100vh;
        background-position-x: 50%;
    }
}

@media (max-width: 768px) {
    ul.buttons {
        display: none;
    }

    .content-container {
        margin: 2rem;
    }
    .home-img {  
        background-size: 100% auto;
        background-position: 0 0;
        position: absolute;
    }
    .home-img-clear {
        margin-top: 50vh;
    }
    .logo {
        font-size: 1.2rem;
    }

    .navbar {
        line-height: 1.2rem;
    }
    
}

/* 
 * PLAYING WITH SHAPES
 * 
 * Square & Rectangle: these are pretty simple that can be manipulated with div width and height
 * 
 * Triangle: for any shape with upto 4 edges, we can manipulate simple div and play around with 
 * border properties. For triangle we can have a div with fat borders making a rectangle. However
 * removing top border makes left and right fall over to each other to form triangle. Same behavior
 * can be used to create other shapes.
 *
 * Circle: square with border radius 50%.
 * 
 * Ellipse: Rectangle with border radius 50%.
 *
 * Trapezoid: Trapezoid is a little tricky. When borders are created with thickness they create a
 * block on top of each edge. That leaves TL TR BL BR edges (small corner squares) empty. So CSS
 * divides this 50-50 (diagonal partition). So if size of original block is 0, we'll end up with 
 * diagonal line partitions. (For a block of small size with thick borders, imagine overall figure
 * as pyramid with chopped top and seen as a top view).
 * 
 */
.triangle {
    display: inline-block;
    width: 0px;
    border-left: 50px solid rgba(0,0,0,0);
    border-right: 50px solid rgba(0,0,0,0);
    border-bottom: 50px solid red;
}

.square {
    display: inline-block;
    width: 50px;
    height: 50px;
    background: red;
}

.rectangle {
    display: inline-block;
    width: 75px;
    height: 50px;
    background: red;
}

.circle {
    display: inline-block;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: red;   
}

.ellipse {
    display: inline-block;
    width: 100px;
    height: 50px;
    border-radius: 50%;
    background: red;
}

.trapezoid {
    display: inline-block;
    width: 40px;
    border-left: 30px solid rgba(0,0,0,0);
    border-right: 30px solid rgba(0,0,0,0);
    border-bottom: 50px solid red;
}